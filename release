#!/usr/bin/env python
# Copyright (C) 2008, Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import csv
import feedparser
import fileinput
import formatter
import gtk
import htmllib
import optparse
import os
import re
import smtplib
import subprocess
import sys
import urllib
import StringIO

upload_host = 'shell.sugarlabs.org'
upload_root = '/upload/sources/sucrose'
download_uri = 'http://download.sugarlabs.org/sources/sucrose/'
announce_to = 'sugar-devel@lists.sugarlabs.org'

class ReleaseReport(object):
    def __init__(self, version):
        self.version = version
        self.tickets = []
        self.testcases = []

    def generate(self):
        p = subprocess.Popen(['git', 'tag'], stdout=subprocess.PIPE)
        tags = p.stdout.read().split('\n')
        tags = [ tag for tag in tags if tag.startswith('v') ]

        release_tag = 'v' + self.version
        try:
            i = tags.index(release_tag)
        except ValueError:
            print 'The tag you provided does not exist.'
            return

        if i > 0:
            previous = tags[i - 1]
            interval = previous + '..' + release_tag
        else:
            interval = release_tag

        p = subprocess.Popen(['git', 'log', interval,
                              '--pretty=format:%an|||%s'],
                             stdout=subprocess.PIPE)
        commits = p.stdout.read().split('\n')

        tickets = []
        for row in commits:
            author, subject = row.split('|||')

            match = re.search("\#([0-9]*)", subject)
            if match:
                tickets.append(match.group(1))

        for n in tickets:
            f = urllib.urlopen('http://dev.sugarlabs.org/ticket/%s?format=csv' % n)

            reader = csv.DictReader(f)
            row = reader.next()

            ticket = { 'number'  : row['id'],
                       'summary' : row['summary'] }
            self.tickets.append(ticket)
    
            f.close()

            url = 'http://dev.sugarlabs.org/ticket/%s?format=rss' % n

            parser = feedparser.parse(url)

            for entry in parser.entries:
                out = StringIO.StringIO()

                writer = formatter.DumbWriter(out)
                form = formatter.AbstractFormatter(writer)

                html_parser = htmllib.HTMLParser(form)
                html_parser.feed(entry['summary_detail']['value'])
                html_parser.close()

                comment = out.getvalue().strip()

                out.close()

                marker = '|testcase|'
                i = comment.lower().find(marker)
                if i >= 0:
                    i += len(marker)
                    self.testcases.append([n, comment[i:].strip()])

class Release(object):
    def __init__(self):
        self.name = None
        self.version = None

        user, err_ = subprocess.Popen(['git', 'config', 'user.name'],
                                      stdout=subprocess.PIPE).communicate()
        email, err_ = subprocess.Popen(['git', 'config', 'user.email'],
                                       stdout=subprocess.PIPE).communicate()

        self.email = '%s <%s>' % (user.strip('\n'), email.strip('\n'))

    def read_config(self):
        config = open(self.config_path).read()

        m = re.search(self.name_regexp, config)
        self.name = m.group(1)

        m = re.search(self.version_regexp, config)
        self.version = m.group(1)

    def check_version(self):
        p = subprocess.Popen(['git', 'tag'], stdout=subprocess.PIPE)
        tags = p.stdout.read().split('\n')
        tags = [tag for tag in tags if tag != '' ]
        latest_tag = tags[-1]
        if latest_tag.startswith('v'):
            latest_tag = latest_tag[1:]
        if latest_tag != self.version:
            print 'Warning: Tag (%s) does not match version number (%s)' \
                % (latest_tag, self.version)
            print 'You can use the --version option to force a specific version'
            sys.exit(1)

    def next_version(self, current):
        splitted = current.split('.')
        new_minor = int(splitted[-1]) + 1
        splitted[-1] = str(new_minor)

        return '.'.join(splitted)

    def bump_version(self, version):
        config = open(self.config_path).read()

        m = re.search(self.version_regexp, config)
        if version is None:
            version = self.next_version(m.group(1))
        config = config[:m.start(1)] + version + config[m.end(1):]

        open(self.config_path, "w").write(config)

        self.version = version

    def undo_version(self):
        subprocess.check_call(['git', 'checkout', self.config_path])

    def tag(self):
        message = 'Release %s' % self.version

        subprocess.check_call(['git', 'commit', '-a', '-m' , '%s' % message])
        subprocess.check_call(['git', 'tag', 'v%s' % self.version])

    def push(self):
        subprocess.check_call(['git', 'push'])
        subprocess.check_call(['git', 'push', '--tags'])

    def build_tarball(self):
        ret = subprocess.call(self.tarball_command)
        return ret == 0

    def get_tarball_name(self):
        return '%s-%s.tar.bz2' % (self.name, self.version)

    def get_tarball_path(self):
        return self.get_tarball_name()

    def upload(self):
        upload_path = os.path.join(upload_root, self.path_differentiator, 
                                   self.name)
        upload_dest = upload_host + ':' + upload_path

        subprocess.check_call(['ssh', upload_host, 'mkdir', '-m', '775',
                               '-p', upload_path])
        subprocess.check_call(['scp', self.get_tarball_path(), upload_dest])

    def announce(self):
        out = StringIO.StringIO()

        out.write('== Source ==\n\n')
        path = os.path.join(self.path_differentiator, self.name, 
                            self.get_tarball_name())

        out.write(download_uri + path + '\n')

        report = ReleaseReport(self.version)
        report.generate()

        if report.tickets:
            out.write('\n== News ==\n\n')

            for ticket in report.tickets:
                number = ticket['number']
                summary = ticket['summary']

                out.write('* #%s %s\n' % (number, summary))

        if report.testcases:
            out.write('\n== Test cases ==\n\n')

            for number, testcase in report.testcases:
                out.write('#%s\n\n%s\n\n\n' % (number, testcase))

        announce = out.getvalue()
        out.close()

        dialog = gtk.Dialog()
        dialog.set_default_size(400, 400)
        dialog.add_buttons(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                           'Announce', gtk.RESPONSE_OK)

        scrolledwindow = gtk.ScrolledWindow()
        scrolledwindow.set_policy(gtk.POLICY_AUTOMATIC,
                                  gtk.POLICY_AUTOMATIC)

        text_view = gtk.TextView()
        text_view.get_buffer().set_text(announce)
        scrolledwindow.add_with_viewport(text_view)
        text_view.show()

        dialog.vbox.pack_start(scrolledwindow)
        scrolledwindow.show()

        if dialog.run() == gtk.RESPONSE_OK:
            buf = text_view.get_buffer()
            text = buf.get_text(buf.get_start_iter(), buf.get_end_iter())
            subject = '[RELEASE] %s-%s' % (self.name, self.version)

            announce_filename = '.sugar-announce'
            f = open(announce_filename, 'w')
            f.write('From: %s\nTo: %s\nSubject: %s\n%s' % \
                    (self.email, announce_to, subject, text))
            f.close()

            subprocess.check_call(['scp', announce_filename,
                                   upload_host + ':~'])
            subprocess.check_call(['ssh', upload_host,
                                   '/usr/sbin/sendmail', '-t', '<', 
                                   announce_filename])
            subprocess.check_call(['ssh', upload_host,
                                   'rm', announce_filename])

            os.unlink(announce_filename)

class ActivityRelease(Release):
    def __init__(self):
        Release.__init__(self)

        self.config_path = os.path.join('activity', 'activity.info')
        self.name_regexp = 'name\s*=\s*(.*)'
        self.version_regexp = 'activity_version\s*=\s*(.*)'
        self.tarball_command = ['./setup.py', 'dist_source']
        self.path_differentiator = 'fructose'

    def get_tarball_path(self):
        return os.path.join('dist', self.get_tarball_name())

class AutomakeRelease(Release):
    def __init__(self):
        Release.__init__(self)

        self.config_path = 'configure.ac'
        self.name_regexp = 'AC_INIT\(\[.*?\],\[.*?\],\[.*?\],\[(.*?)\]'
        self.version_regexp = 'AC_INIT\(\[.*?\],\[(.*?)\]'
        self.tarball_command = ['make', 'distcheck']
        self.path_differentiator = 'glucose'

def main():
    parser = optparse.OptionParser()
    parser.add_option('-v', '--version', dest='version',
                      help='Release version')
    (options, args) = parser.parse_args()

    if os.path.exists('configure.ac'):
        release = AutomakeRelease()
    elif os.path.exists('setup.py'):
        release = ActivityRelease()
    else:
        print 'Unknown module type.'

    release.read_config()
    if options.version is None:
        release.check_version()

    print 'Bump version number...'
    release.bump_version(options.version)

    print 'Build source tarball...'
    if not release.build_tarball():
        print 'Failed to build source tarball.'
        release.undo_version()
        sys.exit(1)

    print 'Tag the release in git...'
    release.tag()

    print 'Push the changes to remote git...'
    release.push()

    print 'Upload the source tarball...'
    release.upload()

    print 'Announce the release...'
    release.announce()

main()
